/* eslint-disable */

//使用方法
/*
gridDataLayer = OL.openMap.gridDataLayer(map, { visible: true });
gridDataLayer.setData([]).setOption({}).redraw();
//gridDataLayer.setVisible(false);
*/

var _this = {};
var myOL = {
  layer: {},
  source: {},
};
//判断当前JS是通过<script>标签引用的还是通过模块引用的
if (typeof module == "object") {
  myOL.layer.Image = require("ol/layer/Image").default;
  myOL.source.ImageCanvas = require("ol/source/ImageCanvas").default;
} else {
  _this = window;
  myOL = ol;
}

var OL = OL || {};
_this.OL = OL;
OL.OpenMap = OL.OpenMap || function () {};
OL.openMap = OL.openMap || new OL.OpenMap();
OL.openMap.gridDataLayer = function (map, layers, option) {
  var _option = {
    zIndex: 1,
    visible: true,
    resolution: 4, //像素分辨率
    rowNumber: 0, //格点行数
    columnNumber: 0, //格点列数
    topLeftX: 0, //左上角投影坐标X
    topLeftY: 0, //左上角投影坐标Y,投影坐标由上到下值变小
    stepX: 0, //格点横向跨度
    stepY: 0, //格点纵向跨度
    gradient: [
      [0, [82, 71, 141]],
      [2, [83, 82, 180]],
      [4, [68, 103, 195]],
      [6, [59, 143, 193]],
      [8, [73, 178, 158]],
      [10, [76, 196, 92]],
      [12, [92, 208, 74]],
      [14, [153, 220, 69]],
      [18, [235, 224, 53]],
      [22, [234, 168, 61]],
      [26, [227, 103, 87]],
      [30, [181, 47, 95]],
      [34, [131, 23, 67]],
      [38, [68, 10, 25]],
      [42, [43, 0, 1]],
    ],
    opacity: 0.5,
  };
  var pointData = [];
  if (option) {
    setOption(option);
  }

  function setOption(newOption) {
    for (var key in newOption) {
      _option[key] = newOption[key];
    }
    autoSetOption();
    return outObject;
  }

  var imageCanvasLayer = new myOL.layer.Image(_option);
  //添加图层
  map.addLayer(imageCanvasLayer);
  layers.set("IdwGridLayer", imageCanvasLayer);

  function setData(data) {
    pointData = data;
    autoSetOption();
    return outObject;
  }

  function autoSetOption() {
    if (pointData.length == 0) {
      return;
    }
    if (_option.rowNumber && !_option.columnNumber) {
      _option.columnNumber = Math.round(pointData.length / _option.rowNumber);
    }
    if (_option.columnNumber && !_option.rowNumber) {
      _option.rowNumber = Math.round(pointData.length / _option.columnNumber);
    }
  }

  function redraw() {
    imageCanvasLayer.setSource(
      new myOL.source.ImageCanvas({
        canvasFunction: function (
          extent,
          resolution,
          pixelRatio,
          size,
          projection
        ) {
          var canvas_s = document.createElement("canvas");
          canvas_s.width = Math.ceil(size[0] / _option.resolution / pixelRatio);
          canvas_s.height = Math.ceil(
            size[1] / _option.resolution / pixelRatio
          );

          var ctx_s = canvas_s.getContext("2d");
          onDrawLayer(
            ctx_s,
            canvas_s.width,
            canvas_s.height,
            _option.resolution
          );

          var canvas = document.createElement("canvas");
          canvas.width = size[0];
          canvas.height = size[1];
          var ctx = canvas.getContext("2d");
          ctx.drawImage(canvas_s, 0, 0, canvas.width, canvas.height);
          return canvas;
        },
        ratio: 1,
      })
    );
    return outObject;
  }

  function onDrawLayer(ctx, w, h, resolution) {
    ctx.clearRect(0, 0, w, h);
    var imgData = ctx.getImageData(0, 0, w, h);
    var colorScale = {
      bounds: [
        _option.gradient[0][0],
        _option.gradient[_option.gradient.length - 1][0],
      ],
      gradient: µ.segmentedColorScale(_option.gradient),
    };

    for (var i = 0; i < w; i++) {
      for (var j = 0; j < h; j++) {
        var p = [i, j]; //屏幕像素点
        var pt = map.getCoordinateFromPixel([
          p[0] * resolution,
          p[1] * resolution,
        ]); //像素点的投影坐标
        var pointValue = interpolatePoint(pt);
        if (pointValue != null) {
          var color = gradientValueColor(pointValue, colorScale);
          var imgIndex = 4 * (i + j * w);
          imgData.data[imgIndex] = color[0];
          imgData.data[imgIndex + 1] = color[1];
          imgData.data[imgIndex + 2] = color[2];
          imgData.data[imgIndex + 3] = color[3];
        }
      }
    }
    ctx.putImageData(imgData, 0, 0);
  }

  function setVisible(visible) {
    _option.visible = visible;
    imageCanvasLayer.setVisible(visible);
    return outObject;
  }

  function getVisible() {
    return imageCanvasLayer.getVisible();
  }

  function clear() {
    imageCanvasLayer.setSource(
      new myOL.source.ImageCanvas({
        canvasFunction: function (
          extent,
          resolution,
          pixelRatio,
          size,
          projection
        ) {
          var canvas = document.createElement("canvas");
          canvas.width = size[0];
          canvas.height = size[1];
          var ctx = canvas.getContext("2d");
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          return canvas;
        },
        ratio: 1,
      })
    );
    return outObject;
  }

  function destroy() {
    map.removeLayer(imageCanvasLayer);
    return outObject;
  }

  var µ = (function () {
    var τ = 2 * Math.PI;
    var rad = Math.PI / 180.0;
    var H = 0.000036;

    /**
     * @returns {Boolean} true if the specified value is truthy.
     */
    function isTruthy(x) {
      return !!x;
    }

    /**
     * @returns {Boolean} true if the specified value is not null and not undefined.
     */
    function isValue(x) {
      return x !== null && x !== undefined;
    }

    /**
     * @returns {Object} the first argument if not null and not undefined, otherwise the second argument.
     */
    function coalesce(a, b) {
      return isValue(a) ? a : b;
    }

    /**
     * @returns {Number} returns remainder of floored division, i.e., floor(a / n). Useful for consistent modulo
     *          of negative numbers. See http://en.wikipedia.org/wiki/Modulo_operation.
     */
    function floorMod(a, n) {
      var f = a - n * Math.floor(a / n);
      return f === n ? 0 : f;
    }

    /**
     * @returns {Number} distance between two points having the form [x, y].
     */
    function distance(a, b) {
      var Δx = b[0] - a[0];
      var Δy = b[1] - a[1];
      return Math.sqrt(Δx * Δx + Δy * Δy);
    }

    /**
     * @returns {Number} the value x clamped to the range [low, high].
     */
    function clamp(x, low, high) {
      return Math.max(low, Math.min(x, high));
    }

    /**
     * @returns {number} the fraction of the bounds [low, high] covered by the value x, after clamping x to the
     *          bounds. For example, given bounds=[10, 20], this method returns 1 for x>=20, 0.5 for x=15 and 0
     *          for x<=10.
     */
    function proportion(x, low, high) {
      return (µ.clamp(x, low, high) - low) / (high - low);
    }

    /**
     * @returns {number} the value p within the range [0, 1], scaled to the range [low, high].
     */
    function spread(p, low, high) {
      return p * (high - low) + low;
    }

    /**
     * Pad number with leading zeros. Does not support fractional or negative numbers.
     */
    function zeroPad(n, width) {
      var s = n.toString();
      var i = Math.max(width - s.length, 0);
      return new Array(i + 1).join("0") + s;
    }

    /**
     * @returns {String} the specified string with the first letter capitalized.
     */
    function capitalize(s) {
      return s.length === 0 ? s : s.charAt(0).toUpperCase() + s.substr(1);
    }

    /**
     * @returns {Boolean} true if agent is probably firefox. Don't really care if this is accurate.
     */
    function isFF() {
      return /firefox/i.test(navigator.userAgent);
    }

    /**
     * @returns {Boolean} true if agent is probably a mobile device. Don't really care if this is accurate.
     */
    function isMobile() {
      return /android|blackberry|iemobile|ipad|iphone|ipod|opera mini|webos/i.test(
        navigator.userAgent
      );
    }

    function isEmbeddedInIFrame() {
      return window != window.top;
    }

    function segmentedColorScale(segments) {
      var points = [],
        interpolators = [],
        ranges = [];
      for (var i = 0; i < segments.length - 1; i++) {
        points.push(segments[i + 1][0]);
        interpolators.push(
          colorInterpolator(segments[i][1], segments[i + 1][1])
        );
        ranges.push([segments[i][0], segments[i + 1][0]]);
      }

      return function (point, alpha) {
        var i;
        for (i = 0; i < points.length - 1; i++) {
          if (point <= points[i]) {
            break;
          }
        }
        var range = ranges[i];
        return interpolators[i](µ.proportion(point, range[0], range[1]), alpha);
      };
    }

    function colorInterpolator(start, end) {
      var r = start[0],
        g = start[1],
        b = start[2];
      var Δr = end[0] - r,
        Δg = end[1] - g,
        Δb = end[2] - b;
      return function (i, a) {
        return [
          Math.floor(r + i * Δr),
          Math.floor(g + i * Δg),
          Math.floor(b + i * Δb),
          a,
        ];
      };
    }

    function formatVectorDegree(u, v) {
      var d = (Math.atan2(-u, -v) / τ) * 360; // calculate into-the-wind cardinal degrees
      var wd = Math.round(((d + 360) % 360) / 1) * 1; // shift [-180, 180] to [0, 360], and round to nearest 1.
      return parseInt(wd);
    }

    function calcalateDirection(u, v) {
      var dir = Math.atan2(u, v) / rad + 180;
      return parseInt(dir);
    }

    function formatVectorIntensity(u, v) {
      return parseFloat(Math.sqrt(u * u + v * v).toFixed(1));
    }

    function getUVFromIntensityDirection(s, d) {
      var dd = d * rad;
      var u = s * Math.sin(dd);
      var v = s * Math.cos(dd);
      return [-u, -v];
    }

    /**
     * caculate the great circle distance
     * @param {Object} lat1
     * @param {Object} lng1
     * @param {Object} lat2
     * @param {Object} lng2
     */
    function getGreatCircleDistance(lat1, lng1, lat2, lng2) {
      var radLat1 = rad * lat1;
      var radLat2 = rad * lat2;

      var a = radLat1 - radLat2;
      var b = rad * lng1 - rad * lng2;

      var s =
        2 *
        Math.asin(
          Math.sqrt(
            Math.pow(Math.sin(a / 2), 2) +
              Math.cos(radLat1) *
                Math.cos(radLat2) *
                Math.pow(Math.sin(b / 2), 2)
          )
        );

      var EARTH_RADIUS = 6378.137; //单位KM
      s = s * EARTH_RADIUS;
      s = Math.round(s * 10000) / 10000.0;

      return s;
    }
    return {
      isTruthy: isTruthy,
      isValue: isValue,
      coalesce: coalesce,
      floorMod: floorMod,
      distance: distance,
      clamp: clamp,
      proportion: proportion,
      spread: spread,
      zeroPad: zeroPad,
      capitalize: capitalize,
      isFF: isFF,
      isMobile: isMobile,
      isEmbeddedInIFrame: isEmbeddedInIFrame,
      segmentedColorScale: segmentedColorScale,
      formatVectorDegree: formatVectorDegree,
      formatVectorIntensity: formatVectorIntensity,
      calcalateDirection: calcalateDirection,
      getUVFromIntensityDirection: getUVFromIntensityDirection,
      getGreatCircleDistance: getGreatCircleDistance,
    };
  })();

  function interpolatePoint(pt) {
    var idx = getPointRowColIndex(pt);
    //超出数据范围的不需要
    if (idx.row < 0 || idx.row >= _option.rowNumber - 1) {
      return null;
    }
    if (idx.col < 0 || idx.col >= _option.columnNumber - 1) {
      return null;
    }

    var coord00 = getPointCoord(idx.row, idx.col);
    var g00 = getPointValue(idx.row, idx.col);
    var g01 = getPointValue(idx.row, idx.col + 1);
    var g10 = getPointValue(idx.row + 1, idx.col);
    var g11 = getPointValue(idx.row + 1, idx.col + 1);

    var x = Math.abs(pt[0] - coord00[0]) / _option.stepX;
    var y = Math.abs(pt[1] - coord00[1]) / _option.stepY;

    var value = gisbillinear.bilinearInterpolateVector(
      x,
      y,
      g00,
      g01,
      g10,
      g11
    ); //双线性插值
    return value;
  }

  function getPointRowColIndex(pt) {
    var rowIndex = Math.floor((_option.topLeftY - pt[1]) / _option.stepY);
    var colIndex = Math.floor((pt[0] - _option.topLeftX) / _option.stepX);
    return {
      row: rowIndex,
      col: colIndex,
    };
  }

  function getPointValue(rowIndex, colIndex) {
    var idx = rowIndex * _option.columnNumber + colIndex;
    if (idx >= pointData.length) {
      return null;
    }
    return pointData[idx];
  }

  function getPointCoord(rowIndex, colIndex) {
    var y = _option.topLeftY - rowIndex * _option.stepY;
    var x = _option.topLeftX + colIndex * _option.stepX;
    var coord = [x, y];
    return coord;
  }

  var gisbillinear = (function () {
    function bilinearInterpolateScalar(x, y, g00, g10, g01, g11) {
      var rx = 1 - x;
      var ry = 1 - y;
      return g00 * rx * ry + g10 * x * ry + g01 * rx * y + g11 * x * y;
    }

    function bilinearInterpolateVector(x, y, g00, g10, g01, g11) {
      if (g00 == null || g10 == null || g01 == null || g11 == null) {
        return null;
      }
      var rx = 1 - x;
      var ry = 1 - y;
      var a = rx * ry,
        b = x * ry,
        c = rx * y,
        d = x * y;

      return g00 * a + g10 * b + g01 * c + g11 * d;
    }

    return {
      bilinearInterpolateVector: bilinearInterpolateVector,
      bilinearInterpolateScalar: bilinearInterpolateScalar,
    };
  })();

  function gradientValueColor(value, scale) {
    var OVERLAY_ALPHA = Math.floor(_option.opacity * 255);
    var bounds = scale.bounds;
    return scale.gradient(
      Math.max(Math.min(value, bounds[1]), bounds[0]),
      OVERLAY_ALPHA
    );
  }

  var outObject = {
    setData: setData,
    setOption: setOption,
    redraw: redraw,
    setVisible: setVisible,
    getVisible: getVisible,
    clear: clear,
    destroy: destroy,
  };

  return outObject;
};

//导出模块，若当前JS是通过<script>标签引用的，这里会报错，需要注释掉
export default _this;

/* eslint-enable */
